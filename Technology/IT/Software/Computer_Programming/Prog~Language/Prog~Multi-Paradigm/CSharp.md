Odd Releases often have breaking Changes and sometimes require new .NET Runtimes. 
Even Releases have long-time Support. 

## CSharp-1

#has_/time_/started :: 2002-01 

has been modeled to comply with Java initially. 
It did not support Generics and introduced Boxing as Convenience/Syntactic Sugar. 
It also introduced `[Attribute]`,  `struct`s and `IDisposable`. 

Extension Methods were a big Leap! 

## CSharp-1.2

#has_/time_/started :: 2003-04 

`foreach` loop called [Dispose](https://learn.microsoft.com/en-us/dotnet/api/system.idisposable.dispose)  at the end 

## CSharp-2

#has_/time_/started :: 2005-11 

major features of C# 2.0, released in 2005, along with Visual Studio 2005:

- [Generics](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics)  with Type Inference. 
- [Partial types](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods#partial-classes)
- [Anonymous methods](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/delegate-operator)
- [Nullable value types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types)
- [Iterators](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/iterators)
- [Covariance and contravariance](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/covariance-contravariance/)

Other C# 2.0 features added capabilities to existing features:

- Getter/setter separate accessibility
- Method group conversions (delegates)
- Static classes
- Delegate inference

## CSharp-3

#has_/time_/started :: 2007-11 

along with Visual Studio 2008 and .NET Framework version 3.5. 
This version marked a major change in the growth of C#. 

- [Auto-implemented properties](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties)
- [Anonymous types](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/anonymous-types)
- [Query expressions](https://learn.microsoft.com/en-us/dotnet/csharp/linq/get-started/query-expression-basics)
- [Lambda expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions)
- [Expression trees](https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/expression-trees)
- [Extension methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)
- [Implicitly typed local variables](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/declarations#implicitly-typed-local-variables)
- [Partial methods](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/partial-member)
- [Object and collection initializers](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers) 

## CSharp-4

#has_/time_/started :: 2010-04 

released with Visual Studio 2010, introduced some interesting new features:

- [Dynamic binding](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types)
- [Named/optional arguments](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments)
- [Generic covariant and contravariant](https://learn.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance)
- [Embedded interop types](https://learn.microsoft.com/en-us/dotnet/framework/interop/type-equivalence-and-embedded-interop-types) 
- 
## CSharp-5

#has_/time_/started :: 2012-08 

- [Asynchronous members](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/)
- [Caller info attributes](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information) 

## CSharp-6

#has_/time_/started :: 2015-07 

- [Static imports](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive)
- [Exception filters](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/when)
- [Auto-property initializers](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties)
- [Expression bodied members](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-operator#expression-body-definition)
- [Null propagator](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-)
- [String interpolation](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated)
- [nameof operator](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/nameof)

Other new features include:

- Index initializers
- Await in catch/finally blocks
- Default values for getter-only properties
## CSharp-7

#has_/time_/started :: 2017-03 

- Out variables
- [Tuples and deconstruction](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples)
- [Pattern matching](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching)
- [Local functions](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/local-functions)
- [Expanded expression bodied members](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members)
- [Ref locals](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/declarations#reference-variables)
- [Ref returns](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/jump-statements#ref-returns)

Other features included:

- [Discards](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards)
- [Binary Literals and Digit Separators](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types#integer-literals)
- [Throw expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements#the-throw-expression) 
- 
## CSharp-7.1

#has_/time_/started :: 2017-08 


## CSharp-7.2

#has_/time_/started :: 2017-11 


## CSharp-7.3

#has_/time_/started :: 2018-05 


## CSharp-8

#has_/time_/started :: 2019-09 


## CSharp-9

#has_/time_/started :: 2020-11 

- [Records](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record)
- [Init only setters](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/init)
- [Top-level statements](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/top-level-statements)
- Pattern matching enhancements: [relational patterns](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#relational-patterns) and [logical patterns](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#logical-patterns)
- [Performance and interop](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history#performance-and-interop)
    - [Native sized integers](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/native-integers)
    - [Function pointers](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers)
    - [Suppress emitting localsinit flag](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/skip-localsinit.md)
    - [Module initializers](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/module-initializers)
    - [New features for partial methods](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/extending-partial-methods)
- [Fit and finish features](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history#fit-and-finish-features)
    - [Target-typed `new` expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/target-typed-new)
    - [`static` anonymous functions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/static-anonymous-functions)
    - [Target-typed conditional expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/target-typed-conditional-expression)
    - [Covariant return types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/covariant-returns)
    - [Extension `GetEnumerator` support for `foreach` loops](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/extension-getenumerator)
    - [Lambda discard parameters](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/lambda-discard-parameters)
    - [Attributes on local functions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/local-function-attributes)

## CSharp-10

2021-11 

C# 10 adds the following features and enhancements to the C# language:

- [Record structs](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record)
- [Improvements of structure types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct#struct-initialization-and-default-values)
- [Interpolated string handlers](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated#compilation-of-interpolated-strings)
- [`global using` directives](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive)
- [File-scoped namespace declaration](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/namespace)
- [Extended property patterns](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/extended-property-patterns)
- Lambda expressions can have a [natural type](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions#natural-type-of-a-lambda-expression), where the compiler can infer a delegate type from the lambda expression or method group.
- Lambda expressions can declare a [return type](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions#explicit-return-type) when the compiler can't infer it.
- [Attributes](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions#attributes) can be applied to lambda expressions.
- In C# 10, `const` strings can be initialized using [string interpolation](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated) if all the placeholders are themselves constant strings.
- In C# 10, you can add the `sealed` modifier when you override `ToString` in a [record](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record) type.
- Warnings for definite assignment and null-state analysis are more accurate.
- Allow both assignment and declaration in the same deconstruction.
- [Allow `AsyncMethodBuilder` attribute on methods](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/general#asyncmethodbuilder-attribute)
- [CallerArgumentExpression attribute](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information#argument-expressions)
- C# 10 supports a new format for the `#line` pragma.

## CSharp-11

#has_/time_/started :: 2022-11 

### Generic [Attribute< T>]s 

### String Notation Features
#### Newlines allowed in {string} interpolations

#### Raw string literals with triple quotes 

### add the [`required` modifier](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/required) to properties and fields to enforce constructors and callers to initialize those values.

### specify the `u8` suffix on a string literal to specify UTF-8 character encoding.
### Generic math support 

There are several language features that enable generic math support:

- `static virtual` members in interfaces
- checked user defined operators
- relaxed shift operators
- unsigned right-shift operator

###  `file` scoped access modifier to create a type with visibility only inside the same source file.
## CSharp-12

#has_/time_/started :: 2023-11 

### Collection-Expressions 

These are much more concise readable. 
When the Type can be inferred, you can 
- replace `new[] { ... }` 
- with `[...]` 
This goes especially well with 2D and 3D Arrays, because you 
- need to specify the Type only once at the Declaration or even skip it when obvious to the Compiler. 
- all Vectors can be written in the same brief Syntax below each other 

### Primary constructors for `class` and `struct` 

### addition of `ref readonly` parameters 
APIs created before `in` was introduced might use `ref` even though the argument isn't modified. 
Those APIs can be updated with `ref readonly`.

### define default values for parameters on lambda expressions. 

### use the `using` alias directive to alias any type, not just named types. 

### Inline Fixed-size Arrays on the Stack 

An _inline array_ is declared as a `struct`:
```
[System.Runtime.CompilerServices.InlineArray(10)]
public struct Buffer {
    private int _element0;
}
```
You use them like any other array:
```
var buffer = new Buffer();
for (int i = 0; i < 10; i++) {
    buffer[i] = i;
}

foreach (var i in buffer) {
    Console.WriteLine(i);
}
```

The difference is that the compiler can take advantage of known information about an inline array. 
You likely consume inline arrays as you would any other array.

### [ExperimentalAttribute] 

Types, methods, or assemblies can be marked with the [System.Diagnostics.CodeAnalysis.ExperimentalAttribute](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.codeanalysis.experimentalattribute) to indicate an experimental feature. 
This is the opposite to the [[ObsoleteAttribute]] 

## CSharp-13 

#has_/time_/started :: 2024-11 

requires .net9 

### ## `params` with any collection Type 

### ## New [System.Threading.Lock](https://learn.microsoft.com/en-us/dotnet/api/system.threading.lock) type with faster API than Monitor 

Instead of using any ``new object()`` use a `new Lock()`

### `\e` for the Escape Character instead of `\u001b` 

### Use [OverloadResolutionPriorityAttribute](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.overloadresolutionpriorityattribute) to prefer one overload over another 

### declare `partial` properties and `partial` indexers 

### `ref struct` Improvements 

#### `ref` and `unsafe` in iterators and `async` methods 

#### allows `ref struct` in generic Types 

#### `ref struct` implement Interfaces 


## CSharp-14 

#has_/time_/started :: 2025-11 

### new syntax to define _extension members_ without `this`. 

The new syntax enables you to declare _extension properties_ in addition to extension methods.

### The `field` keyword

Instead of declaring a private Variable `_msg`....
```
private string _msg;
public string Message {
    get => _msg;
    set => _msg = value ?? throw new ArgumentNullException(nameof(value));
}
```
...you can now simplify your code to:
```
public string Message { get;
    set => field = value ?? throw new ArgumentNullException(nameof(value));
}
```

### implicit Span< T> Conversions. 

### `nameof(List<T>)` now possible 

### declare [instance constructors](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors#partial-constructors) and [events](https://learn.microsoft.com/en-us/dotnet/csharp/event-pattern) as [partial members](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/partial-member). 

### Compound Assignment Operators `op=` are overridable 

previously any `op=` Operator executed the `op` and assigned the result to the left Variable w/o Side-Effects. 
These Operators now allow for more efficient in-place Code, which would incur side-effects. 
Since Memory-Management is very efficient and you can switch to `struct`s, this does not seem too useful.  

### Null-conditional assignment 
Instead of 
```
if (customer is not null) {
    customer.Order = GetCurrentOrder();
    customer[4] = myCust;
}
```
You can simplify the preceding code using the `?.` or `?[]` operator:
```
customer?.Order = GetCurrentOrder();
customer?[4] = myCust;
```

compound assignment operators like `+=` and `-=` are also allowed: 
